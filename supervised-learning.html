<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="RasterFrames brings the power of Spark DataFrames to geospatial raster data.">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="RasterFrames brings the power of Spark DataFrames to geospatial raster data.">
<link rel="shortcut icon" href="assets/images/RasterFrames_32x32.ico">
<title>Supervised Machine Learning Â· RasterFrames</title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="assets/stylesheets/application-palette.22915126.css">
<meta name="theme-color" content="#546e7a" />
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="assets/custom.css">
</head>
<body
data-md-color-primary="blue-grey"
data-md-color-accent="light-blue"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="RasterFrames" class="md-header-nav__button md-logo">
<img src="assets/images/RF-R.svg" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
RasterFrames
</span>
<span class="md-header-nav__topic">
Supervised Machine Learning
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/locationtech/rasterframes"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
locationtech/rasterframes
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="RasterFrames" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="assets/images/RF-R.svg" width="24" height="24">
</a>
<a href="index.html" title="RasterFrames">
RasterFrames
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/locationtech/rasterframes"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
locationtech/rasterframes
</div>
</a>

</div>
<ul>
  <li><a href="description.html" class="page">Overview</a></li>
  <li><a href="getting-started.html" class="page">Getting Started</a></li>
  <li><a href="concepts.html" class="page">Concepts</a></li>
  <li><a href="raster-io.html" class="page">Raster Data I/O</a>
  <ul>
    <li><a href="raster-catalogs.html" class="page">Raster Catalogs</a></li>
    <li><a href="raster-read.html" class="page">Reading Raster Data</a></li>
    <li><a href="raster-write.html" class="page">Writing Raster Data</a></li>
  </ul></li>
  <li><a href="vector-data.html" class="page">Vector Data</a></li>
  <li><a href="raster-processing.html" class="page">Raster Processing</a>
  <ul>
    <li><a href="local-algebra.html" class="page">Local Map Algebra</a></li>
    <li><a href="nodata-handling.html" class="page">&ldquo;NoData&rdquo; Handling</a></li>
    <li><a href="zonal-algebra.html" class="page">Zonal Map Algebra</a></li>
    <li><a href="aggregation.html" class="page">Aggregation</a></li>
    <li><a href="time-series.html" class="page">Time Series</a></li>
    <li><a href="machine-learning.html" class="page">Machine Learning</a>
    <ul>
      <li><a href="unsupervised-learning.html" class="page">Unsupervised Machine Learning</a></li>
      <li><a href="supervised-learning.html" class="active page">Supervised Machine Learning</a></li>
    </ul></li>
  </ul></li>
  <li><a href="numpy-pandas.html" class="page">NumPy and Pandas</a></li>
  <li><a href="languages.html" class="page">Scala and SQL</a></li>
  <li><a href="reference.html" class="page">Function Reference</a></li>
  <li><a href="release-notes.html" class="page">Release Notes</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="supervised-learning.html#supervised-machine-learning" class="header">Supervised Machine Learning</a>
  <ul>
    <li><a href="supervised-learning.html#create-and-read-raster-catalog" class="header">Create and Read Raster Catalog</a></li>
    <li><a href="supervised-learning.html#data-prep" class="header">Data Prep</a></li>
    <li><a href="supervised-learning.html#masking-poor-quality-cells" class="header">Masking Poor Quality Cells</a></li>
    <li><a href="supervised-learning.html#create-ml-pipeline" class="header">Create ML Pipeline</a></li>
    <li><a href="supervised-learning.html#train-the-model" class="header">Train the Model</a></li>
    <li><a href="supervised-learning.html#model-evaluation" class="header">Model Evaluation</a></li>
    <li><a href="supervised-learning.html#visualize-prediction" class="header">Visualize Prediction</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.8.3
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="supervised-learning.html#supervised-machine-learning" class="header">Supervised Machine Learning</a>
  <ul>
    <li><a href="supervised-learning.html#create-and-read-raster-catalog" class="header">Create and Read Raster Catalog</a></li>
    <li><a href="supervised-learning.html#data-prep" class="header">Data Prep</a></li>
    <li><a href="supervised-learning.html#masking-poor-quality-cells" class="header">Masking Poor Quality Cells</a></li>
    <li><a href="supervised-learning.html#create-ml-pipeline" class="header">Create ML Pipeline</a></li>
    <li><a href="supervised-learning.html#train-the-model" class="header">Train the Model</a></li>
    <li><a href="supervised-learning.html#model-evaluation" class="header">Model Evaluation</a></li>
    <li><a href="supervised-learning.html#visualize-prediction" class="header">Visualize Prediction</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#supervised-machine-learning" name="supervised-machine-learning" class="anchor"><span class="anchor-link"></span></a>Supervised Machine Learning</h1>
<p>In this example we will demonstrate how to fit and score a supervised learning model with a sample of Sentinel-2 data and hand-drawn vector labels over different <a href="https://en.wikipedia.org/wiki/Land_cover">land cover</a> types.</p>
<h2><a href="#create-and-read-raster-catalog" name="create-and-read-raster-catalog" class="anchor"><span class="anchor-link"></span></a>Create and Read Raster Catalog</h2>
<p>The first step is to create a Spark DataFrame containing our imagery data. To achieve that we will create <a href="raster-catalogs.html#creating-a-catalog">a catalog DataFrame</a>. In the catalog, each row represents a distinct area and time, and each column is the URI to a band&rsquo;s image product. In this example our catalog just has one row. After reading the catalog, the resulting Spark DataFrame may have many rows per URI, with a column corresponding to each band.</p>
<p>The imagery for feature data will come from <a href="https://earth.esa.int/web/sentinel/user-guides/sentinel-2-msi/resolutions/spatial">eleven bands of 60 meter resolution Sentinel-2</a> imagery. We also will use the <a href="https://earth.esa.int/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm">scene classification (SCL)</a> data to identify high quality, non-cloudy pixels.</p>
<pre class="prettyprint"><code class="language-python">uri_base = &#39;s3://s22s-test-geotiffs/luray_snp/{}.tif&#39;
bands = [&#39;B01&#39;, &#39;B02&#39;, &#39;B03&#39;, &#39;B04&#39;, &#39;B05&#39;, &#39;B06&#39;, &#39;B07&#39;, &#39;B08&#39;, &#39;B09&#39;, &#39;B11&#39;, &#39;B12&#39;]
cols = [&#39;SCL&#39;] + bands

catalog_df = pd.DataFrame([
    {b: uri_base.format(b) for b in cols}
])

df = spark.read.raster(catalog_df, catalog_col_names=cols, tile_dimensions=(128, 128)) \
					  .repartition(100)

df = df.select(
    rf_crs(df.B01).alias(&#39;crs&#39;),
    rf_extent(df.B01).alias(&#39;extent&#39;),
    rf_tile(df.SCL).alias(&#39;scl&#39;),
    rf_tile(df.B01).alias(&#39;B01&#39;),
    rf_tile(df.B02).alias(&#39;B02&#39;),
    rf_tile(df.B03).alias(&#39;B03&#39;),
    rf_tile(df.B04).alias(&#39;B04&#39;),
    rf_tile(df.B05).alias(&#39;B05&#39;),
    rf_tile(df.B06).alias(&#39;B06&#39;),
    rf_tile(df.B07).alias(&#39;B07&#39;),
    rf_tile(df.B08).alias(&#39;B08&#39;),
    rf_tile(df.B09).alias(&#39;B09&#39;),
    rf_tile(df.B11).alias(&#39;B11&#39;),
    rf_tile(df.B12).alias(&#39;B12&#39;),
)
df.printSchema()
</code></pre>
<pre><code>root
 |-- crs: struct (nullable = true)
 |    |-- crsProj4: string (nullable = false)
 |-- extent: struct (nullable = true)
 |    |-- xmin: double (nullable = false)
 |    |-- ymin: double (nullable = false)
 |    |-- xmax: double (nullable = false)
 |    |-- ymax: double (nullable = false)
 |-- scl: tile (nullable = true)
 |-- B01: tile (nullable = true)
 |-- B02: tile (nullable = true)
 |-- B03: tile (nullable = true)
 |-- B04: tile (nullable = true)
 |-- B05: tile (nullable = true)
 |-- B06: tile (nullable = true)
 |-- B07: tile (nullable = true)
 |-- B08: tile (nullable = true)
 |-- B09: tile (nullable = true)
 |-- B11: tile (nullable = true)
 |-- B12: tile (nullable = true)
</code></pre>
<h2><a href="#data-prep" name="data-prep" class="anchor"><span class="anchor-link"></span></a>Data Prep</h2>
<h3><a href="#label-data" name="label-data" class="anchor"><span class="anchor-link"></span></a>Label Data</h3>
<p>The land classification labels are based on a small set of hand drawn polygons in the GeoJSON file <a href="https://github.com/locationtech/rasterframes/blob/develop/pyrasterframes/src/test/resources/luray-labels.geojson">here</a>. The property <code>id</code> indicates the type of land cover in each area. For these integer values, 1 is forest, 2 is cropland, and 3 is developed areas.</p>
<p>We will create a very small Spark DataFrame of the label shapes and then join it to the raster DataFrame. Such joins are typically expensive, but in this case both datasets are quite small. To speed up the join for the small vector DataFrame, we put the <code>broadcast</code> hint on it, which will tell Spark to put a copy of it on each Spark executor.</p>
<p>After the raster and vector data are joined, we will convert the vector shapes into <em>tiles</em> using the <a href="reference.html#rf-rasterize"><code>rf_rasterize</code></a> function. This procedure is sometimes called &ldquo;burning in&rdquo; a geometry into a raster. The values in the resulting <em>tile</em> cells are the <code>id</code> property of the GeoJSON, which we will use as labels in our supervised learning task. In areas where the geometry does not intersect, the cells will contain NoData.</p>
<pre class="prettyprint"><code class="language-python">crses = df.select(&#39;crs.crsProj4&#39;).distinct().collect()
print(&#39;Found &#39;, len(crses), &#39;distinct CRS.&#39;)
crs = crses[0][0]

from pyspark import SparkFiles
spark.sparkContext.addFile(&#39;https://github.com/locationtech/rasterframes/raw/develop/pyrasterframes/src/test/resources/luray-labels.geojson&#39;) 

label_df = spark.read.geojson(SparkFiles.get(&#39;luray-labels.geojson&#39;)) \
    .select(&#39;id&#39;, st_reproject(&#39;geometry&#39;, lit(&#39;EPSG:4326&#39;), lit(crs)).alias(&#39;geometry&#39;)) \
    .hint(&#39;broadcast&#39;)

df_joined = df.join(label_df, st_intersects(st_geometry(&#39;extent&#39;), &#39;geometry&#39;)) \
    .withColumn(&#39;dims&#39;, rf_dimensions(&#39;B01&#39;))

df_labeled = df_joined.withColumn(&#39;label&#39;, 
   rf_rasterize(&#39;geometry&#39;, st_geometry(&#39;extent&#39;), &#39;id&#39;, &#39;dims.cols&#39;, &#39;dims.rows&#39;)
)
</code></pre>
<pre><code>Found  1 distinct CRS.
</code></pre>
<h2><a href="#masking-poor-quality-cells" name="masking-poor-quality-cells" class="anchor"><span class="anchor-link"></span></a>Masking Poor Quality Cells</h2>
<p>To filter only for good quality pixels, we follow roughly the same procedure as demonstrated in the <a href="nodata-handling.html#masking">quality masking</a> section of the chapter on NoData. Instead of actually setting NoData values in the unwanted cells of any of the imagery bands, we will just filter out the mask cell values later in the process.</p>
<pre class="prettyprint"><code class="language-python">from pyspark.sql.functions import lit

mask_part = df_labeled \
    .withColumn(&#39;nodata&#39;, rf_local_equal(&#39;scl&#39;, lit(0))) \
    .withColumn(&#39;defect&#39;, rf_local_equal(&#39;scl&#39;, lit(1))) \
    .withColumn(&#39;cloud8&#39;, rf_local_equal(&#39;scl&#39;, lit(8))) \
    .withColumn(&#39;cloud9&#39;, rf_local_equal(&#39;scl&#39;, lit(9))) \
    .withColumn(&#39;cirrus&#39;, rf_local_equal(&#39;scl&#39;, lit(10)))

df_mask_inv = mask_part \
    .withColumn(&#39;mask&#39;, rf_local_add(&#39;nodata&#39;, &#39;defect&#39;)) \
    .withColumn(&#39;mask&#39;, rf_local_add(&#39;mask&#39;, &#39;cloud8&#39;)) \
    .withColumn(&#39;mask&#39;, rf_local_add(&#39;mask&#39;, &#39;cloud9&#39;)) \
    .withColumn(&#39;mask&#39;, rf_local_add(&#39;mask&#39;, &#39;cirrus&#39;)) \
    .drop(&#39;nodata&#39;, &#39;defect&#39;, &#39;cloud8&#39;, &#39;cloud9&#39;, &#39;cirrus&#39;)
    
# at this point the mask contains 0 for good cells and 1 for defect, etc
# convert cell type and set value 1 to NoData
df_mask = df_mask_inv.withColumn(&#39;mask&#39;,
  rf_with_no_data(rf_convert_cell_type(&#39;mask&#39;, &#39;uint8&#39;), 1.0)
)

df_mask.printSchema()
</code></pre>
<pre><code>root
 |-- crs: struct (nullable = true)
 |    |-- crsProj4: string (nullable = false)
 |-- extent: struct (nullable = true)
 |    |-- xmin: double (nullable = false)
 |    |-- ymin: double (nullable = false)
 |    |-- xmax: double (nullable = false)
 |    |-- ymax: double (nullable = false)
 |-- scl: tile (nullable = true)
 |-- B01: tile (nullable = true)
 |-- B02: tile (nullable = true)
 |-- B03: tile (nullable = true)
 |-- B04: tile (nullable = true)
 |-- B05: tile (nullable = true)
 |-- B06: tile (nullable = true)
 |-- B07: tile (nullable = true)
 |-- B08: tile (nullable = true)
 |-- B09: tile (nullable = true)
 |-- B11: tile (nullable = true)
 |-- B12: tile (nullable = true)
 |-- id: long (nullable = true)
 |-- geometry: geometry (nullable = true)
 |-- dims: struct (nullable = true)
 |    |-- cols: short (nullable = false)
 |    |-- rows: short (nullable = false)
 |-- label: tile (nullable = true)
 |-- mask: tile (nullable = true)
</code></pre>
<h2><a href="#create-ml-pipeline" name="create-ml-pipeline" class="anchor"><span class="anchor-link"></span></a>Create ML Pipeline</h2>
<p>We import various Spark components that we need to construct our <a href="https://spark.apache.org/docs/latest/ml-pipeline.html"><code>Pipeline</code></a>. These are the objects that will work in sequence to conduct the data preparation and modeling.</p>
<pre class="prettyprint"><code class="language-python">from pyrasterframes import TileExploder
from pyrasterframes.rf_types import NoDataFilter

from pyspark.ml.feature import VectorAssembler
from pyspark.ml.classification import DecisionTreeClassifier
from pyspark.ml.evaluation import MulticlassClassificationEvaluator
from pyspark.ml import Pipeline
</code></pre>
<p>SparkML requires that each observation be in its own row, and those observations be packed into a single <a href="https://spark.apache.org/docs/latest/api/python/pyspark.ml.html#module-pyspark.ml.linalg"><code>Vector</code></a> object. The first step is to &ldquo;explode&rdquo; the <em>tiles</em> into a single row per cell or pixel with the <code>TileExploder</code> (see also <a href="reference.html#rf_explode_tiles"><code>rf_explode_tiles</code></a>). If a <em>tile</em> cell contains a NoData it will become a null value after the exploder stage. Then we use the <code>NoDataFilter</code> to filter out any rows that missing or null values, which will cause an error during training. Finally we use the SparkML <code>VectorAssembler</code> to create that <code>Vector</code>.</p>
<p>Recall above we set undesirable pixels to NoData, so the <code>NoDataFilter</code> will remove them at this stage. We apply the filter to the <code>mask</code> column and the <code>label</code> column, the latter being used during training. When it is time to score the model, the pipeline will ignore the fact that there is no <code>label</code> column on the input DataFrame.</p>
<pre class="prettyprint"><code class="language-python">exploder = TileExploder()

noDataFilter = NoDataFilter() \
  .setInputCols([&#39;label&#39;, &#39;mask&#39;])

assembler = VectorAssembler() \
  .setInputCols(bands) \
  .setOutputCol(&quot;features&quot;)
</code></pre>
<p>We are going to use a decision tree for classification. You can swap out one of the other multi-class classification algorithms if you like. With the algorithm selected we can assemble our modeling pipeline.</p>
<pre class="prettyprint"><code class="language-python">classifier = DecisionTreeClassifier() \
  .setLabelCol(&#39;label&#39;) \
  .setFeaturesCol(assembler.getOutputCol())

pipeline = Pipeline() \
  .setStages([exploder, noDataFilter, assembler, classifier])

pipeline.getStages()
</code></pre>
<pre><code>[TileExploder_42cea46a93c9e2430563,
 NoDataFilter_484da89c0de9b0c29fed,
 VectorAssembler_4e79879c792200cd8ec9,
 DecisionTreeClassifier_41fdad4da4cad4242868]
</code></pre>
<h2><a href="#train-the-model" name="train-the-model" class="anchor"><span class="anchor-link"></span></a>Train the Model</h2>
<p>The next step is to actually run each step of the Pipeline we created, including fitting the decision tree model. We filter the DataFrame for only <em>tiles</em> intersecting the label raster because the label shapes are relatively sparse over the imagery. It would be logically equivalent to either include or exclude thi step, but it is more efficient to filter because it will mean less data going into the pipeline.</p>
<pre class="prettyprint"><code class="language-python">model_input = df_mask.filter(rf_tile_sum(&#39;label&#39;) &gt; 0).cache()
model = pipeline.fit(model_input)
</code></pre>
<h2><a href="#model-evaluation" name="model-evaluation" class="anchor"><span class="anchor-link"></span></a>Model Evaluation</h2>
<p>To view the model&rsquo;s performance, we first call the pipeline&rsquo;s <code>transform</code> method on the training dataset. This transformed dataset will have the model&rsquo;s prediction included in each row. We next construct an evaluator and pass it the transformed dataset to easily compute the performance metric. We can also create custom metrics using a variety of DataFrame or SQL transformations.</p>
<pre class="prettyprint"><code class="language-python">prediction_df = model.transform(df_mask) \
                       .drop(assembler.getOutputCol()).cache()
prediction_df.printSchema()

eval = MulticlassClassificationEvaluator(
    predictionCol=classifier.getPredictionCol(),
    labelCol=classifier.getLabelCol(),
    metricName=&#39;accuracy&#39;
)

accuracy = eval.evaluate(prediction_df)
print(&quot;\nAccuracy:&quot;, accuracy)
</code></pre>
<pre><code>root
 |-- crs: struct (nullable = true)
 |    |-- crsProj4: string (nullable = false)
 |-- extent: struct (nullable = true)
 |    |-- xmin: double (nullable = false)
 |    |-- ymin: double (nullable = false)
 |    |-- xmax: double (nullable = false)
 |    |-- ymax: double (nullable = false)
 |-- id: long (nullable = true)
 |-- geometry: geometry (nullable = true)
 |-- dims: struct (nullable = true)
 |    |-- cols: short (nullable = false)
 |    |-- rows: short (nullable = false)
 |-- column_index: integer (nullable = false)
 |-- row_index: integer (nullable = false)
 |-- scl: double (nullable = false)
 |-- B01: double (nullable = false)
 |-- B02: double (nullable = false)
 |-- B03: double (nullable = false)
 |-- B04: double (nullable = false)
 |-- B05: double (nullable = false)
 |-- B06: double (nullable = false)
 |-- B07: double (nullable = false)
 |-- B08: double (nullable = false)
 |-- B09: double (nullable = false)
 |-- B11: double (nullable = false)
 |-- B12: double (nullable = false)
 |-- label: double (nullable = false)
 |-- mask: double (nullable = false)
 |-- rawPrediction: vector (nullable = true)
 |-- probability: vector (nullable = true)
 |-- prediction: double (nullable = false)


Accuracy: 0.9742420788693869
</code></pre>
<p>As an example of using the flexibility provided by DataFrames, the code below computes and displays the confusion matrix. </p>
<pre class="prettyprint"><code class="language-python">cnf_mtrx = prediction_df.groupBy(classifier.getPredictionCol()) \
    .pivot(classifier.getLabelCol()) \
    .count() \
    .sort(classifier.getPredictionCol())
cnf_mtrx
</code></pre>
<table>
  <thead>
    <tr>
      <th>prediction </th>
      <th>1.0 </th>
      <th>2.0 </th>
      <th>3.0 </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.0 </td>
      <td>6620 </td>
      <td>16 </td>
      <td>54 </td>
    </tr>
    <tr>
      <td>2.0 </td>
      <td>2 </td>
      <td>1738 </td>
      <td>52 </td>
    </tr>
    <tr>
      <td>3.0 </td>
      <td>45 </td>
      <td>170 </td>
      <td>4464 </td>
    </tr>
  </tbody>
</table>
<h2><a href="#visualize-prediction" name="visualize-prediction" class="anchor"><span class="anchor-link"></span></a>Visualize Prediction</h2>
<p>Because the pipeline included a <code>TileExploder</code>, we will recreate the tiled data structure. The explosion transformation includes metadata enabling us to recreate the <em>tiles</em>. See the <a href="reference.html#rf-assemble-tile"><code>rf_assemble_tile</code></a> function documentation for more details. In this case, the pipeline is scoring on all areas, regardless of whether they intersect the label polygons. This is simply done by removing the <code>label</code> column, as <a href="supervised-learning.html#create-ml-pipeline">discussed above</a>.</p>
<pre class="prettyprint"><code class="language-python">scored = model.transform(df_mask.drop(&#39;label&#39;))

retiled = scored \
    .groupBy(&#39;extent&#39;, &#39;crs&#39;) \
    .agg(
        rf_assemble_tile(&#39;column_index&#39;, &#39;row_index&#39;, &#39;prediction&#39;, 128, 128).alias(&#39;prediction&#39;),
        rf_assemble_tile(&#39;column_index&#39;, &#39;row_index&#39;, &#39;B04&#39;, 128, 128).alias(&#39;red&#39;),
        rf_assemble_tile(&#39;column_index&#39;, &#39;row_index&#39;, &#39;B03&#39;, 128, 128).alias(&#39;grn&#39;),
        rf_assemble_tile(&#39;column_index&#39;, &#39;row_index&#39;, &#39;B02&#39;, 128, 128).alias(&#39;blu&#39;)
    )
retiled.printSchema()
</code></pre>
<pre><code>root
 |-- extent: struct (nullable = true)
 |    |-- xmin: double (nullable = false)
 |    |-- ymin: double (nullable = false)
 |    |-- xmax: double (nullable = false)
 |    |-- ymax: double (nullable = false)
 |-- crs: struct (nullable = true)
 |    |-- crsProj4: string (nullable = false)
 |-- prediction: tile (nullable = true)
 |-- red: tile (nullable = true)
 |-- grn: tile (nullable = true)
 |-- blu: tile (nullable = true)
</code></pre>
<p>Take a look at a sample of the resulting output and the corresponding area&rsquo;s red-green-blue composite image.</p>
<pre class="prettyprint"><code class="language-python">sample = retiled \
    .select(&#39;prediction&#39;, rf_rgb_composite(&#39;red&#39;, &#39;grn&#39;, &#39;blu&#39;).alias(&#39;rgb&#39;)) \
    .sort(-rf_tile_sum(rf_local_equal(&#39;prediction&#39;, lit(3.0)))) \
    .first()

sample_rgb = sample[&#39;rgb&#39;]
mins = np.nanmin(sample_rgb.cells, axis=(0,1))
plt.imshow((sample_rgb.cells -  mins) / (np.nanmax(sample_rgb.cells, axis=(0,1)) - mins))
</code></pre>
<pre><code>setup.py:5: RuntimeWarning: overflow encountered in int_scalars
  #
</code></pre>
<pre><code>&lt;matplotlib.image.AxesImage at 0x114225cd0&gt;
</code></pre>
<p><img src="figures/supervised-learning_display_rgb_1.png" /></p>
<p>Recall the label coding: 1 is forest (purple), 2 is cropland (green) and 3 is developed areas(yellow).</p>
<pre class="prettyprint"><code class="language-python">display(sample[&#39;prediction&#39;])
</code></pre>
<p><img src="figures/supervised-learning_display_prediction_1.png" /></p>
</div>
<div>
<a href="https://github.com/locationtech/rasterframes/tree/v0.8.3/pyrasterframes/target/python/docs/supervised-learning.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.8.3
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="unsupervised-learning.html" title="Unsupervised Machine Learning" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Unsupervised Machine Learning
</span>
</div>
</a>
<a href="numpy-pandas.html" title="NumPy and Pandas" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
NumPy and Pandas
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
&copy; 2017-2019 <a href="https://astraea.earth">Astraea</a>, Inc. All rights reserved.
</div>
</div>
</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script>!function(e,a,t,n,o,c,i){e.GoogleAnalyticsObject=o,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),i=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",i.parentNode.insertBefore(c,i)}(window,document,"script",0,"ga"),ga("create","UA-106630615-1"),ga("set","anonymizeIp",!0),ga("send","pageview");var links=document.getElementsByTagName("a");Array.prototype.map.call(links,function(e){e.host!=document.location.host&&e.addEventListener("click",function(){var a=e.getAttribute("data-md-action")||"follow";ga("send","event","outbound",a,e.href)})});if(document.forms.search){var query=document.forms.search.query;query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}</script>

</body>
</html>
