<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106630615-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments)};
gtag('js', new Date());

gtag('config', 'UA-106630615-1');
</script>

<title>NoData Handling · RasterFrames</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='RasterFrames brings the power of Spark DataFrames to geospatial raster data.'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/groups.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>

<link rel="icon" href="images/RasterFrames_16x16.ico" sizes="16x16"/>
<link rel="icon" href="images/RasterFrames_32x32.ico" sizes="32x32"/>

<style>
.md-left { float: left; }
.md-right { float: right; }
.md-clear { clear: both; }
table { font-size: 80%; }
code { font-size: 0.75em !important; }
</style>
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>RasterFrames
</a>
<div class="version-number">
0.8.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="description.html" class="page">Overview</a></li>
  <li><a href="getting-started.html" class="page">Getting Started</a></li>
  <li><a href="concepts.html" class="page">Concepts</a></li>
  <li><a href="raster-io.html" class="page">Raster Data I/O</a>
  <ul>
    <li><a href="raster-catalogs.html" class="page">Raster Catalogs</a></li>
    <li><a href="raster-read.html" class="page">Reading Raster Data</a></li>
    <li><a href="raster-write.html" class="page">Writing Raster Data</a></li>
  </ul></li>
  <li><a href="vector-data.html" class="page">Vector Data</a></li>
  <li><a href="raster-processing.html" class="page">Raster Processing</a>
  <ul>
    <li><a href="local-algebra.html" class="page">Local Map Algebra</a></li>
    <li><a href="nodata-handling.html" class="active page">&ldquo;NoData&rdquo; Handling</a></li>
    <li><a href="aggregation.html" class="page">Aggregation</a></li>
    <li><a href="time-series.html" class="page">Time Series</a></li>
    <li><a href="machine-learning.html" class="page">Machine Learning</a></li>
  </ul></li>
  <li><a href="numpy-pandas.html" class="page">NumPy and Pandas</a></li>
  <li><a href="languages.html" class="page">API Languages</a></li>
  <li><a href="reference.html" class="page">Function Reference</a></li>
  <li><a href="release-notes.html" class="page">Release&nbsp;Notes</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<img style="max-height: 60px;" src="images/RasterFramesLogo.png" />
<!-- <div class="title"><a href="index.html">RasterFrames</a></div>
 -->
<a href="http://www.astraea.earth" class="logo show-for-medium">
<img style="max-height: 40px;" src="images/astraea.png"/>
</a>
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>RasterFrames
</a>
<div class="version-number">
0.8.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="description.html" class="page">Overview</a></li>
  <li><a href="getting-started.html" class="page">Getting Started</a></li>
  <li><a href="concepts.html" class="page">Concepts</a></li>
  <li><a href="raster-io.html" class="page">Raster Data I/O</a>
  <ul>
    <li><a href="raster-catalogs.html" class="page">Raster Catalogs</a></li>
    <li><a href="raster-read.html" class="page">Reading Raster Data</a></li>
    <li><a href="raster-write.html" class="page">Writing Raster Data</a></li>
  </ul></li>
  <li><a href="vector-data.html" class="page">Vector Data</a></li>
  <li><a href="raster-processing.html" class="page">Raster Processing</a>
  <ul>
    <li><a href="local-algebra.html" class="page">Local Map Algebra</a></li>
    <li><a href="nodata-handling.html" class="active page">&ldquo;NoData&rdquo; Handling</a></li>
    <li><a href="aggregation.html" class="page">Aggregation</a></li>
    <li><a href="time-series.html" class="page">Time Series</a></li>
    <li><a href="machine-learning.html" class="page">Machine Learning</a></li>
  </ul></li>
  <li><a href="numpy-pandas.html" class="page">NumPy and Pandas</a></li>
  <li><a href="languages.html" class="page">API Languages</a></li>
  <li><a href="reference.html" class="page">Function Reference</a></li>
  <li><a href="release-notes.html" class="page">Release&nbsp;Notes</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="index.html">RasterFrames</a></li>
  <li><a href="raster-processing.html">Raster Processing</a></li>
  <li>&ldquo;NoData&rdquo; Handling</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#handling" name="handling" class="anchor"><span class="anchor-link"></span></a>&ldquo;NoData&rdquo; Handling</h1>
<h2><a href="#what-is-nodata-" name="what-is-nodata-" class="anchor"><span class="anchor-link"></span></a>What is NoData?</h2>
<p>In raster operations, the preservation and correct processing of missing observations is very important. In <a href="https://www.oreilly.com/learning/handling-missing-data">most DataFrames and scientific computing</a>, the idea of missing data is expressed as a <code>null</code> or <code>NaN</code> value. However, a great deal of raster data is stored for space efficiency, which typically leads to use of integral values with a <a href="https://en.wikipedia.org/wiki/Sentinel_value">&ldquo;sentinel&rdquo; value</a> designated to represent missing observations. This sentinel value varies across data products and is usually called the &ldquo;NoData&rdquo; value.</p>
<p>RasterFrames provides a variety of functions to inspect and manage NoData within <em>tiles</em>.</p>
<h2><a href="#cell-types" name="cell-types" class="anchor"><span class="anchor-link"></span></a>Cell Types</h2>
<p>To understand how NoData is handled in RasterFrames, we first need to understand the different underlying types of data called cell types. RasterFrames cell types are GeoTrellis <code>CellType</code>s, so the <a href="https://geotrellis.readthedocs.io/en/latest/guide/core-concepts.html?#working-with-cell-values">GeoTrellis documentation</a> is a valuable resource on how these are defined.</p>
<p>The <code>CellType</code> class from the <code>rf_types</code> submodule allows us to create a representation of any valid cell type. There are convenience methods to create instances for a variety of basic types.</p>
<pre class="prettyprint"><code class="language-python">from pyrasterframes.rf_types import CellType
CellType.bool()
CellType.int8()
CellType.uint8()
CellType.int16()
CellType.uint16()
CellType.int32()
CellType.float32()
CellType.float64()
</code></pre>
<p>We can also inspect the cell type of a given <em>tile</em> or <code>proj_raster</code> column.</p>
<pre class="prettyprint"><code class="language-python">spark.read.raster(&#39;https://s22s-test-geotiffs.s3.amazonaws.com/luray_snp/B02.tif&#39;) \
    .select(rf_cell_type(&#39;proj_raster&#39;)).distinct().show()
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_cell_type(proj_raster) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[uint16raw] </td>
    </tr>
  </tbody>
</table>
<h3><a href="#understanding-cell-types-and-nodata" name="understanding-cell-types-and-nodata" class="anchor"><span class="anchor-link"></span></a>Understanding Cell Types and NoData</h3>
<p>We can use the methods on the <code>CellType</code> class to learn more about a specific cell type. Let&rsquo;s consider the cell type of our sample data above.</p>
<pre class="prettyprint"><code class="language-python">ct = CellType(&#39;uint16raw&#39;)
ct, ct.is_floating_point(), ct.has_no_data()
</code></pre>
<pre><code>(uint16raw, False, False)
</code></pre>
<p>We can see that for the above data source, there is no defined NoData value. This means that each value is interpreted as a valid observation. Often such data is meant to be combined with another band indicating the quality of observations at each location. The lack of NoData is indicated by the <code>raw</code> at the end of the type name. Consider for contrast the <code>uint16</code> cell type.</p>
<pre class="prettyprint"><code class="language-python">from pyrasterframes.rf_types import CellType
ct = CellType(&#39;uint16&#39;)
ct, ct.is_floating_point(), ct.has_no_data(), ct.no_data_value()
</code></pre>
<pre><code>(uint16, False, True, 0)
</code></pre>
<p>In this case, the minimum value of 0 is designated as the NoData value. For integral-valued cell types, the NoData is typically zero, the maximum, or the minimum value for the underlying data type. The NoData value can also be a user-defined value. In that case the value is designated with <code>ud</code>.</p>
<pre class="prettyprint"><code class="language-python">CellType.uint16().with_no_data_value(99).cell_type_name
</code></pre>
<pre><code>&#39;uint16ud99&#39;
</code></pre>
<p>Floating point types have <code>NaN</code> as the NoData value by default. However, a user-defined NoData can be set.</p>
<pre class="prettyprint"><code class="language-python">print(CellType.float32().no_data_value())
print(CellType.float32().with_no_data_value(-99.9).no_data_value())
</code></pre>
<pre><code>nan
-99.9
</code></pre>
<h2><a href="#masking" name="masking" class="anchor"><span class="anchor-link"></span></a>Masking</h2>
<p>Let&rsquo;s continue the example above with Sentinel-2 data. Band 2 is blue and has no defined NoData. The quality information is in a separate file called the scene classification (SCL), which delineates areas of missing data and probable clouds. For more information on this, see the <a href="https://earth.esa.int/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm">Sentinel-2 algorithm overview</a>. Figure 3 tells us how to interpret the scene classification. For this example, we will exclude NoData, defective pixels, probable clouds, and cirrus clouds: values 0, 1, 8, 9, and 10.</p>
<p><img src="static/sentinel-2-scene-classification-labels.png" alt="Sentinel-2 Scene Classification Values" /></p>
<p>Credit: <a href="https://earth.esa.int/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm">Sentinel-2 algorithm overview</a></p>
<p>The first step is to create a catalog with our band of interest and the SCL band. We read the data from the catalog, so the blue band and SCL <em>tiles</em> are aligned across rows.</p>
<pre class="prettyprint"><code class="language-python">from pyspark.sql import Row

blue_uri = &#39;https://s22s-test-geotiffs.s3.amazonaws.com/luray_snp/B02.tif&#39;
scl_uri = &#39;https://s22s-test-geotiffs.s3.amazonaws.com/luray_snp/SCL.tif&#39;
cat = spark.createDataFrame([Row(blue=blue_uri, scl=scl_uri),])
unmasked = spark.read.raster(catalog=cat, catalog_col_names=[&#39;blue&#39;, &#39;scl&#39;])
unmasked.printSchema()
</code></pre>
<pre><code>root
 |-- blue_path: string (nullable = false)
 |-- scl_path: string (nullable = false)
 |-- blue: struct (nullable = true)
 |    |-- tile_context: struct (nullable = false)
 |    |    |-- extent: struct (nullable = false)
 |    |    |    |-- xmin: double (nullable = false)
 |    |    |    |-- ymin: double (nullable = false)
 |    |    |    |-- xmax: double (nullable = false)
 |    |    |    |-- ymax: double (nullable = false)
 |    |    |-- crs: struct (nullable = false)
 |    |    |    |-- crsProj4: string (nullable = false)
 |    |-- tile: tile (nullable = false)
 |-- scl: struct (nullable = true)
 |    |-- tile_context: struct (nullable = false)
 |    |    |-- extent: struct (nullable = false)
 |    |    |    |-- xmin: double (nullable = false)
 |    |    |    |-- ymin: double (nullable = false)
 |    |    |    |-- xmax: double (nullable = false)
 |    |    |    |-- ymax: double (nullable = false)
 |    |    |-- crs: struct (nullable = false)
 |    |    |    |-- crsProj4: string (nullable = false)
 |    |-- tile: tile (nullable = false)
</code></pre>
<pre class="prettyprint"><code class="language-python">unmasked.select(rf_cell_type(&#39;blue&#39;), rf_cell_type(&#39;scl&#39;)).distinct().show()
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_cell_type(blue) </th>
      <th>rf_cell_type(scl) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[uint16raw] </td>
      <td>[uint8raw] </td>
    </tr>
  </tbody>
</table>
<p>Drawing on <a href="local-algebra.html">local map algebra</a> techniques, we will create new <em>tile</em> columns that are indicators of unwanted pixels, as defined above. Since the mask column is an integer type, the addition is equivalent to a logical or, so the boolean true values are 1.</p>
<pre class="prettyprint"><code class="language-python">from pyspark.sql.functions import lit

mask_part = unmasked.withColumn(&#39;nodata&#39;, rf_local_equal(&#39;scl&#39;, lit(0))) \
                    .withColumn(&#39;defect&#39;, rf_local_equal(&#39;scl&#39;, lit(1))) \
                    .withColumn(&#39;cloud8&#39;, rf_local_equal(&#39;scl&#39;, lit(8))) \
                    .withColumn(&#39;cloud9&#39;, rf_local_equal(&#39;scl&#39;, lit(9))) \
                    .withColumn(&#39;cirrus&#39;, rf_local_equal(&#39;scl&#39;, lit(10)))

one_mask = mask_part.withColumn(&#39;mask&#39;, rf_local_add(&#39;nodata&#39;, &#39;defect&#39;)) \
                    .withColumn(&#39;mask&#39;, rf_local_add(&#39;mask&#39;, &#39;cloud8&#39;)) \
                    .withColumn(&#39;mask&#39;, rf_local_add(&#39;mask&#39;, &#39;cloud9&#39;)) \
                    .withColumn(&#39;mask&#39;, rf_local_add(&#39;mask&#39;, &#39;cirrus&#39;))

one_mask.select(rf_cell_type(&#39;mask&#39;)).distinct().show()
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_cell_type(mask) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool] </td>
    </tr>
  </tbody>
</table>
<p>Because there is not a NoData already defined, we will choose one. In this particular example, the minimum value is greater than zero, so we can use 0 as the NoData value.</p>
<pre class="prettyprint"><code class="language-python">one_mask.agg(rf_agg_stats(&#39;blue&#39;).min.alias(&#39;blue_min&#39;)).show()
</code></pre>
<table>
  <thead>
    <tr>
      <th>blue_min </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3.0 </td>
    </tr>
  </tbody>
</table>
<p>We can now construct the cell type string for our blue band&rsquo;s cell type, designating 0 as NoData.</p>
<pre class="prettyprint"><code class="language-python">blue_ct = one_mask.select(rf_cell_type(&#39;blue&#39;)).distinct().first()[0][0]
masked_blue_ct = CellType(blue_ct).with_no_data_value(0)
masked_blue_ct.cell_type_name
</code></pre>
<pre><code>&#39;uint16ud0&#39;
</code></pre>
<p>Now we will use the <a href="reference.html#rf-mask-by-value"><code>rf_mask_by_value</code></a> to designate the cloudy and other unwanted pixels as NoData in the blue column by converting the cell type and applying the mask.</p>
<pre class="prettyprint"><code class="language-python">with_nd = rf_convert_cell_type(&#39;blue&#39;, masked_blue_ct)
masked = one_mask.withColumn(&#39;blue_masked&#39;,
                             rf_mask_by_value(with_nd, &#39;mask&#39;, lit(1))) \
                 .drop(&#39;nodata&#39;, &#39;defect&#39;, &#39;cloud8&#39;, &#39;cloud9&#39;, &#39;cirrus&#39;, &#39;blue&#39;)
</code></pre>
<p>We can verify that the number of NoData cells in the resulting <code>blue_masked</code> column matches the total of the boolean <code>mask</code> <em>tile</em> to ensure our logic is correct.</p>
<pre class="prettyprint"><code class="language-python">masked.select(rf_no_data_cells(&#39;blue_masked&#39;), rf_tile_sum(&#39;mask&#39;)).show(10)
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_no_data_cells(blue_masked) </th>
      <th>rf_tile_sum(mask) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4475 </td>
      <td>4475.0 </td>
    </tr>
    <tr>
      <td>0 </td>
      <td>0.0 </td>
    </tr>
    <tr>
      <td>0 </td>
      <td>0.0 </td>
    </tr>
    <tr>
      <td>0 </td>
      <td>0.0 </td>
    </tr>
    <tr>
      <td>5 </td>
      <td>5.0 </td>
    </tr>
    <tr>
      <td>29 </td>
      <td>29.0 </td>
    </tr>
    <tr>
      <td>186 </td>
      <td>186.0 </td>
    </tr>
    <tr>
      <td>1835 </td>
      <td>1835.0 </td>
    </tr>
    <tr>
      <td>3 </td>
      <td>3.0 </td>
    </tr>
    <tr>
      <td>2 </td>
      <td>2.0 </td>
    </tr>
  </tbody>
</table>
<p>It&rsquo;s also nice to view a sample. The white regions are areas of NoData.</p>
<pre class="prettyprint"><code class="language-python">sample = masked.orderBy(-rf_no_data_cells(&#39;blue_masked&#39;)).select(rf_tile(&#39;blue_masked&#39;), rf_tile(&#39;scl&#39;)).first()
display(sample[0])
</code></pre>
<p><img src="figures/nodata-handling_display_blu_1.png" alt="Blue band masked against selected SCL values" /></p>
<p>And the original SCL data. The bright yellow is a cloudy region in the original image.</p>
<pre class="prettyprint"><code class="language-python">display(sample[1])
</code></pre>
<p><img src="figures/nodata-handling_display_scl_1.png" alt="SCL tile for above" /></p>
<h2><a href="#nodata-and-local-arithmetic" name="nodata-and-local-arithmetic" class="anchor"><span class="anchor-link"></span></a>NoData and Local Arithmetic</h2>
<p>Let&rsquo;s now explore how the presence of NoData affects <a href="local-algebra.html">local map algebra</a> operations. To demonstrate the behavior, lets create two <em>tiles</em>. One <em>tile</em> will have values of 0 and 1, and the other will have values of just 0.</p>
<pre class="prettyprint"><code class="language-python">tile_size = 100
x = np.zeros((tile_size, tile_size), dtype=&#39;int16&#39;)
x[:,tile_size//2:] = 1
x = Tile(x)
y = Tile(np.zeros((tile_size, tile_size), dtype=&#39;int16&#39;))

rf = spark.createDataFrame([Row(x=x, y=y)])
print(&#39;x&#39;)
display(x)
</code></pre>
<pre><code>x
</code></pre>
<p><img src="figures/nodata-handling_local_arith_1.png" /></p>
<pre class="prettyprint"><code class="language-python">print(&#39;y&#39;)
display(y)
</code></pre>
<pre><code>y
</code></pre>
<p><img src="figures/nodata-handling_display_1_1.png" /></p>
<p>Now, let&rsquo;s create a new column from <code>x</code> with the value of 1 changed to NoData. Then, we will add this new column with NoData to the <code>y</code> column. As shown below, the result of the sum also has NoData (represented in white). In general for local algebra operations, Data + NoData = NoData.</p>
<pre class="prettyprint"><code class="language-python">masked_rf = rf.withColumn(&#39;x_nd&#39;, rf_mask_by_value(&#39;x&#39;, &#39;x&#39;, lit(1)) )
masked_rf = masked_rf.withColumn(&#39;x_nd_y_sum&#39;, rf_local_add(&#39;x_nd&#39;, &#39;y&#39;))
row = masked_rf.collect()[0]
print(&#39;x with NoData&#39;)
display(row.x_nd)
</code></pre>
<pre><code>x with NoData
</code></pre>
<p><img src="figures/nodata-handling_display_2_1.png" /></p>
<pre class="prettyprint"><code class="language-python">print(&#39;x with NoData plus y&#39;)
display(row.x_nd_y_sum)
</code></pre>
<pre><code>x with NoData plus y
</code></pre>
<p><img src="figures/nodata-handling_display_3_1.png" /> To see more information about possible operations on <em>tile</em> columns, see the <a href="local-algebra.html">local map algebra</a> page and <a href="reference.html#local-map-algebra">function reference</a>.</p>
<h2><a href="#changing-a-tiles-nodata-values" name="changing-a-tiles-nodata-values" class="anchor"><span class="anchor-link"></span></a>Changing a Tile&rsquo;s NoData Values</h2>
<p>One way to mask a <em>tile</em> is to make a new <em>tile</em> with a user defined NoData value. We will explore this method below. First, lets create a DataFrame from a <em>tile</em> with values of 0, 1, 2, and 3. We will use numpy to create a 100x100 <em>tile</em> with vertical bands containing values 0, 1, 2, and 3.</p>
<pre class="prettyprint"><code class="language-python">tile_size = 100
x = np.zeros((tile_size, tile_size), dtype=&#39;int16&#39;)

# setting the values of the columns
for i in range(4):
    x[:, i*tile_size//4:(i+1)*tile_size//4] = i
x = Tile(x)

rf = spark.createDataFrame([Row(tile=x)])
display(x)
</code></pre>
<p><img src="figures/nodata-handling_create_dummy_tile_1.png" alt="Dummy Tile" /></p>
<p>First, we mask the value of 1 by making a new <em>tile</em> column with the user defined cell type &lsquo;uint16ud1&rsquo;. Then, we mask out the value of two by making a <em>tile</em> column with the cell type &lsquo;uint16ud2&rsquo;.</p>
<pre class="prettyprint"><code class="language-python">def get_nodata_ct(nd_val):
	return CellType(&#39;uint16&#39;).with_no_data_value(nd_val)

masked_rf = rf.withColumn(&#39;tile_nd_1&#39;,
                           rf_convert_cell_type(&#39;tile&#39;, get_nodata_ct(1))) \
              .withColumn(&#39;tile_nd_2&#39;,
                          rf_convert_cell_type(&#39;tile_nd_1&#39;, get_nodata_ct(2))) \
</code></pre>
<pre class="prettyprint"><code class="language-python">collected = masked_rf.collect()
</code></pre>
<p>Let&rsquo;s look at the new <em>tiles</em> we created. The <em>tile</em> named <code>tile_nd_1</code> has the 1 values masked out as expected.</p>
<pre class="prettyprint"><code class="language-python">display(collected[0].tile_nd_1)
</code></pre>
<p><img src="figures/nodata-handling_display_4_1.png" /></p>
<p>And the <em>tile</em> named <code>tile_nd_2</code> has the values of 1 and 2 masked out. This is because we created the <em>tile</em> by setting a new user defined NoData value to <code>tile_nd_1</code>, and the values previously masked out in <code>tile_nd_1</code> stayed masked when creating <code>tile_nd_2</code>.</p>
<pre class="prettyprint"><code class="language-python">display(collected[0].tile_nd_2)
</code></pre>
<p><img src="figures/nodata-handling_display_5_1.png" /></p>
<h2><a href="#combining-tiles-with-different-data-types" name="combining-tiles-with-different-data-types" class="anchor"><span class="anchor-link"></span></a>Combining Tiles with Different Data Types</h2>
<p>RasterFrames supports having <em>tile</em> columns with different cell types in a single DataFrame. It is important to understand how these different cell types interact.</p>
<p>Let&rsquo;s first create a RasterFrame that has columns of <code>float</code> and <code>int</code> cell type.</p>
<pre class="prettyprint"><code class="language-python">x = Tile((np.ones((100, 100))*2), CellType.float64())
y = Tile((np.ones((100, 100))*3), CellType.int32())
rf = spark.createDataFrame([Row(x=x, y=y)])

rf.select(rf_cell_type(&#39;x&#39;), rf_cell_type(&#39;y&#39;)).distinct().show()
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_cell_type(x) </th>
      <th>rf_cell_type(y) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[float64] </td>
      <td>[int32] </td>
    </tr>
  </tbody>
</table>
<p>When performing a local operation between <em>tile</em> columns with cell types <code>int</code> and <code>float</code>, the resulting <em>tile</em> cell type will be <code>float</code>. In local algebra over two <em>tiles</em> of different &ldquo;sized&rdquo; cell types, the resulting cell type will be the larger of the two input <em>tiles&rsquo;</em> cell types.</p>
<pre class="prettyprint"><code class="language-python">rf.select(
    rf_cell_type(&#39;x&#39;),
    rf_cell_type(&#39;y&#39;),
    rf_cell_type(rf_local_add(&#39;x&#39;, &#39;y&#39;)).alias(&#39;xy_sum&#39;),
    ).show(1)
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_cell_type(x) </th>
      <th>rf_cell_type(y) </th>
      <th>xy_sum </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[float64] </td>
      <td>[int32] </td>
      <td>[float64] </td>
    </tr>
  </tbody>
</table>
<p>Combining <em>tile</em> columns of different cell types gets a little trickier when user defined NoData cell types are involved. Let&rsquo;s create two <em>tile</em> columns: one with a NoData value of 1, and one with a NoData value of 2 (using our previously defined <code>get_nodata_ct</code> function).</p>
<pre class="prettyprint"><code class="language-python">x_nd_1 = Tile((np.ones((100, 100))*3), get_nodata_ct(1))
x_nd_2 = Tile((np.ones((100, 100))*3), get_nodata_ct(2))
rf_nd = spark.createDataFrame([Row(x_nd_1=x_nd_1, x_nd_2=x_nd_2)])
</code></pre>
<p>Let&rsquo;s try adding the <em>tile</em> columns with different NoData values. When there is an inconsistent NoData value in the two columns, the NoData value of the right-hand side of the sum is kept. In this case, this means the result has a NoData value of 1.</p>
<pre class="prettyprint"><code class="language-python">rf_nd_sum = rf_nd.withColumn(&#39;x_nd_sum&#39;, rf_local_add(&#39;x_nd_2&#39;, &#39;x_nd_1&#39;))
rf_nd_sum.select(rf_cell_type(&#39;x_nd_sum&#39;)).distinct().show()
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_cell_type(x_nd_sum) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[uint16ud1] </td>
    </tr>
  </tbody>
</table>
<p>Reversing the order of the sum changes the NoData value of the resulting column to 2.</p>
<pre class="prettyprint"><code class="language-python">rf_nd_sum = rf_nd.withColumn(&#39;x_nd_sum&#39;, rf_local_add(&#39;x_nd_1&#39;, &#39;x_nd_2&#39;))
rf_nd_sum.select(rf_cell_type(&#39;x_nd_sum&#39;)).distinct().show()
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_cell_type(x_nd_sum) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[uint16ud2] </td>
    </tr>
  </tbody>
</table>
<h2><a href="#nodata-values-in-aggregation" name="nodata-values-in-aggregation" class="anchor"><span class="anchor-link"></span></a>NoData Values in Aggregation</h2>
<p>Let&rsquo;s use the same <em>tile</em> as before to demonstrate how NoData values affect <em>tile</em> aggregations.</p>
<pre class="prettyprint"><code class="language-python">tile_size = 100
x = np.zeros((tile_size, tile_size))
for i in range(4):
    x[:, i*tile_size//4:(i+1)*tile_size//4] = i
x = Tile(x, CellType.int16())

rf = spark.createDataFrame([Row(tile=x)])
display(x)
</code></pre>
<p><img src="figures/nodata-handling_display_6_1.png" /></p>
<p>First we create the two new masked <em>tile</em> columns as before. One with only the value of 1 masked, and the other with and values of 1 and 2 masked.</p>
<pre class="prettyprint"><code class="language-python">masked_rf = rf.withColumn(&#39;tile_nd_1&#39;,
                           rf_convert_cell_type(&#39;tile&#39;, get_nodata_ct(1))) \
              .withColumn(&#39;tile_nd_2&#39;,
                          rf_convert_cell_type(&#39;tile_nd_1&#39;, get_nodata_ct(2)))
</code></pre>
<p>The results of <code>rf_tile_sum</code> vary on the <em>tiles</em> that were masked. This is because any cells with NoData values are ignored in the aggregation. Note that <code>tile_nd_2</code> has the lowest sum, since it has the fewest amount of data cells.</p>
<pre class="prettyprint"><code class="language-python">masked_rf.select(rf_tile_sum(&#39;tile&#39;), rf_tile_sum(&#39;tile_nd_1&#39;), rf_tile_sum(&#39;tile_nd_2&#39;)).show()
</code></pre>
<table>
  <thead>
    <tr>
      <th>rf_tile_sum(tile) </th>
      <th>rf_tile_sum(tile_nd_1) </th>
      <th>rf_tile_sum(tile_nd_2) </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>15000.0 </td>
      <td>12500.0 </td>
      <td>7500.0 </td>
    </tr>
  </tbody>
</table>
<div class="nav-next">
<p><strong>Next:</strong> <a href="aggregation.html">Aggregation</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="nodata-handling.html#handling" class="header">&ldquo;NoData&rdquo; Handling</a>
  <ul>
    <li><a href="nodata-handling.html#what-is-nodata-" class="header">What is NoData?</a></li>
    <li><a href="nodata-handling.html#cell-types" class="header">Cell Types</a></li>
    <li><a href="nodata-handling.html#masking" class="header">Masking</a></li>
    <li><a href="nodata-handling.html#nodata-and-local-arithmetic" class="header">NoData and Local Arithmetic</a></li>
    <li><a href="nodata-handling.html#changing-a-tiles-nodata-values" class="header">Changing a Tile&rsquo;s NoData Values</a></li>
    <li><a href="nodata-handling.html#combining-tiles-with-different-data-types" class="header">Combining Tiles with Different Data Types</a></li>
    <li><a href="nodata-handling.html#nodata-values-in-aggregation" class="header">NoData Values in Aggregation</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">
<div class="small-12 text-center large-9 column">
<div class="copyright">
<span class="text">Copyright &copy; 2019
<a href="http://www.astraea.earth/">Astraea, Inc.</a></span>
</div>
</div>
</div>
</div>
</div>
</section>
</footer>
</div>
</div>
</div>
</body>

<script type="text/javascript" src="lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

</html>
